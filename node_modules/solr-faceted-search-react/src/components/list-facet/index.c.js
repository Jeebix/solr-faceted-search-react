import PropTypes from 'prop-types';
import React from "react";
import cx from "classnames";

import CheckedIcon from "../icons/checked";
import UncheckedIcon from "../icons/unchecked";

class ListFacetItem extends React.Component {

	constructor(props) {
		super(props);
		this.state = { // Etat initial
			facetInclude: ''
		};
	}

	// Fonction qui définit l'état de facetInclude au survol d'une valeur de la facette
	handleFacetItemOver = () => {
		let newLabel = '';
		if (this.props.value.indexOf(this.props.facetVal) > -1) {
			this.props.inverted ? newLabel = 'inclure' : newLabel = 'exclure';
		}
		else {
			/*if (e.shiftKey) {
				this.props.inverted ? newLabel='include' : newLabel='exclude';
			} else {*/
			this.props.inverted ? newLabel = 'exclure' : newLabel = 'inclure';
			/*}*/
		}
		// Définition du nouvel état
		this.setState({ facetInclude: newLabel }, function () {
			console.log(this.state.facetInclude);
		});
	};

	// Fonction qui définit l'état de facetInclude au survol d'une valeur de la facette	
	handleFacetItemOut = () => {
		let newLabel = '';
		this.setState({ facetInclude: newLabel }, function () {
			console.log(this.state.facetInclude);
		});
	}
	
	render() {

		const { value, facetVal, count, facetField, onSelect, inverted } = this.props;

		const invertedClassName = (inverted && value.indexOf(facetVal) > -1) ? "inverted" : "";
		//console.log('### invert : ',invertedClassName)

		return (

			<li
				className={`facet-item-type-${this.props.facetField}  ${invertedClassName} facet-item-list`}
				key={`${facetVal}_${count}`}
				onClick={onSelect}
				onMouseOver={this.handleFacetItemOver}
				onMouseOut={this.handleFacetItemOut}>
				<div className={'list-facet-item-row facet-item-value col-md-9'}>
					<p className='managed-wrap'>{facetVal}</p>
				</div>
				<div className={'facet-item-count col-sm-2'}>
					<p id="facet-value-selection" >
						<small>
							<span className={this.state.facetInclude == 'inclure' ? 'glyphicon glyphicon-plus-sign' : 'glyphicon'}
								styleName={this.state.facetInclude == 'inclure' ? '' : 'visibility: hidden'}></span>
						</small>
						<small className={'align-right'}>
							{parseInt(count).toLocaleString().replace(',', '&thinsp;')}
						</small>
						{//</p>
							//<p  id="facet-value-selection" >
						}

					</p>
				</div>
				<div className={'facet-item-select col-sm-1'}>
					{value.indexOf(facetVal) > -1 ? <CheckedIcon />
						: <UncheckedIcon />}

				</div>

			</li>
		);
	}
};

class ListFacet extends React.Component {

	constructor(props) {
		super(props);

		this.state = {
			filter: "",
			truncateFacetListsAt: props.truncateFacetListsAt,
			facetInclude: ''
		};
	}

	handleClick(e, value) {
		/* search if value is present in selection */
		console.debug("### Start Handlink click ###");
		const foundIdx = this.props.value.indexOf(value);

		console.debug("### Checkbox was ticked ###");
		if (e.shiftKey) {
			console.debug("### Shift was pressed ###");
		}

		if (foundIdx < 0) {
			/* No its not then add passed value to current values and notify */
			this.props.onChange(this.props.field, this.props.value.concat(value));
		} else {
			/* Yes it is then remove passed values from current values and notify */
			this.props.onChange(this.props.field, this.props.value.filter((v, i) => i !== foundIdx));
		}
	}

	mouseOver() {
		this.setState({ hover: true });
	}

	mouseOut() {
		this.setState({ hover: false });
	}

	handleCheckBoxOn() {
		// console.debug("### Checkbox was ticked ###");
		// this.setState({facetInclude : 'exclude'}, function () {
		// console.log(this.state.facetInclude);});
	}


	handleCheckBoxOff() {
		// console.debug("### Checkbox was unticked ###");
		// this.setState({facetInclude : 'include'}, function () {
		// 		console.log(this.state.facetInclude);});
	}

	handleFacetItemOver() {
		this.setState({ facetInclude: 'include' }, function () {
			console.log(this.state.facetInclude);
		});

	}

	toggleExpand() {
		this.props.onSetCollapse(this.props.field, !(this.props.collapse || false));
	}

	toggleInvert() {
		this.props.onSetInvert(this.props.field, !(this.props.invert || false));
		console.log("## INVERT");
	}

	render() {
		const { query, label, facets, field, value, bootstrapCss, facetSort, collapse, invert, icon_class, group, tooltip } = this.props;
		const { truncateFacetListsAt } = this.state;

		//const facetCounts = facets.filter((facet, i) => i % 2 === 1);
		//const facetValues = facets.filter((facet, i) => i % 2 === 0);

		const facetCounts = facets.buckets ? facets.buckets.map((b) => b.count) : [];
		const facetValues = facets.buckets ? facets.buckets.map((b) => b.val) : [];

		const facetSortValue = facetSort ? facetSort :
			query.facetSort ? query.facetSort :
				(query.facetLimit && query.facetLimit > -1 ? "count" : "index");

		const expanded = !(collapse || false);

		const showMoreLink = truncateFacetListsAt > -1 && truncateFacetListsAt < facetValues.length ?
			<li className={cx({ "list-group-item": bootstrapCss })} onClick={() => this.setState({ truncateFacetListsAt: -1 })}>
				Show all ({facetValues.length})
			</li> : null;

		const toggleInvertLink = <a className={cx({ "pull-right": bootstrapCss }, { "inverted": invert })} onClick={this.toggleInvert.bind(this)}>
			{invert ? 'inversé' : 'inverser'}
		</a>;

		return (
			<li className={cx("facet-box", "list-facet", { "list-group-item": bootstrapCss }, query.searchFields.filter((f) => f.field == field).shift().grid)} id={`solr-list-facet-${field}`}>
				<header>
					<h5 title={tooltip}>
						{toggleInvertLink}
						<p onClick={this.toggleExpand.bind(this)} className={cx(group)}>
							{bootstrapCss ? (<span>
								<span className={cx("glyphicon", {
									"glyphicon-collapse-down": expanded,
									"glyphicon-collapse-up": !expanded
								})} />{" "}
							</span>) : null}
							<i className={cx("fa", icon_class)} aria-hidden="true"></i>{label}
						</p>
					</h5>
				</header>
				{expanded ? (
					<div>
						<ul className={cx({ "list-group": bootstrapCss })}>
							{
								/* filtrer les valeurs de facettes visibles (non tronquées)
								   Rendre la facette avec un ListFacetItem si aucun filtre ou si match avec le filtre (comparaison tout en minuscule)
								   value porte le contenu de la requête */
								facetValues.filter((facetValue, i) =>
									truncateFacetListsAt < 0
									|| i < truncateFacetList)
									.map((facetValue, i) =>
										this.state.filter.length === 0
											|| facetValue.toLowerCase().indexOf(this.state.filter.toLowerCase()) > -1 ?
											(
												<ListFacetItem facetVal={facetValue} value={value} count={facetCounts[i]} facetField={field} inverted={invert} onSelect={(e) => this.handleClick(e, facetValue)} />
											) : null
										)
							}
							{showMoreLink}
						</ul>
						{facetValues.length > 4 ? (
							<div>
								<input onChange={(ev) => this.setState({ filter: ev.target.value })} placeholder="Filter... " type="text" value={this.state.filter} />&nbsp;
								<span className={cx({ "btn-group": bootstrapCss })}>
									<button className={cx({ "btn": bootstrapCss, "btn-default": bootstrapCss, "btn-xs": bootstrapCss, active: facetSortValue === "index" })}
										onClick={() => this.props.onFacetSortChange(field, "index")}>
										a-z
									</button>
									<button className={cx({ "btn": bootstrapCss, "btn-default": bootstrapCss, "btn-xs": bootstrapCss, active: facetSortValue === "count" })}
										onClick={() => this.props.onFacetSortChange(field, "count")}>
										0-9
									</button>
								</span>
								<span className={cx({ "btn-group": bootstrapCss, "pull-right": bootstrapCss })}>
									<button className={cx({ "btn": bootstrapCss, "btn-default": bootstrapCss, "btn-xs": bootstrapCss })}
										onClick={() => this.props.onChange(field, [])}>
										clear
									</button>
								</span>
							</div>
						) : null}
					</div>
				) : null}
			</li>
		);
	}
}

ListFacet.defaultProps = {
	value: []
};

ListFacet.propTypes = {
	bootstrapCss: PropTypes.bool,
	children: PropTypes.array,
	collapse: PropTypes.bool,
	facetSort: PropTypes.string,
	facets: PropTypes.array.isRequired,
	field: PropTypes.string.isRequired,
	label: PropTypes.string,
	onChange: PropTypes.func,
	onFacetSortChange: PropTypes.func,
	onSetCollapse: PropTypes.func,
	onSetInvert: PropTypes.func,
	query: PropTypes.object,
	truncateFacetListsAt: PropTypes.number,
	value: PropTypes.array
};

export default ListFacet;
