import PropTypes from 'prop-types';
import React from "react";

import cx from "classnames";

import RangeSlider from "./range-slider";
class RangeFacet extends React.Component {

	constructor(props) {
		super(props);

		this.state = {
			value: props.value,
			lowerValue: '',
			upperValue: ''
		};

		this.handleLowerValueChange = this.handleLowerValueChange.bind(this);
		this.handleUpperValueChange = this.handleUpperValueChange.bind(this);		
	}

	componentWillReceiveProps(nextProps) {
		this.setState({ value: nextProps.value });
	}

	facetsToRange() {
		const { facets } = this.props;

		const buckets =	facets.buckets ? facets.buckets.map((b) => b.val) : [];

		return buckets
			// .filter((facet, i) => i % 2 === 0)
				.map((v) => parseInt(v))
				.sort((a, b) => a > b ? 1 : -1)
				.filter((a, i, me) => i === 0 || i === me.length - 1);
	}

	onRangeChange(range) {
		// console.log("range ", range);
		const bounds = this.facetsToRange();
		
		const lowerBound = bounds[0];
		const upperBound = bounds[1];
		const realRange = upperBound - lowerBound;
		// console.log("range ", range);
		// console.log("bounds", bounds);
		const newState = {
			value: [
				Math.floor(range.lowerLimit * realRange) + lowerBound,
				Math.ceil(range.upperLimit * realRange) + lowerBound
			],
			lowerValue: Math.floor(range.lowerLimit * realRange) + lowerBound,
			upperValue: Math.ceil(range.upperLimit * realRange) + lowerBound
		};
		// console.log("input range : ", newState);

		if(range.refresh) {
			this.props.onChange(this.props.field, newState.value);
			// console.log("############# onRangeChange");
		} else {
			this.setState(newState);
		}
	}

	buildNewRange() {
		let leftInputValue = parseInt(document.getElementById("input-range-left").value);
		let rightInputValue = parseInt(document.getElementById("input-range-right").value);
		let range = this.facetsToRange();
		let lowerLimit = this.getPercentage(range, leftInputValue);
		let upperLimit = this.getPercentage(range, rightInputValue);
		let newRange = { lowerLimit, upperLimit, refresh: true };
		return newRange;
	}

	onRangeUpdate(ev) {
		// console.log("############### onRangeUpdate");
		let newRange = this.buildNewRange();
		this.onRangeChange(newRange);
		return ev.preventDefault();		
	}

	handleKeyDown(e) {
		const ENTER_KEY = 13;
        if (e.keyCode === ENTER_KEY) {
			let newRange = this.buildNewRange();
			this.onRangeChange(newRange);
        }
	}

	getPercentage(range, value) {
		let lowerBound = range[0];
		let upperBound = range[1];
		let realRange = upperBound - lowerBound;

		let atRange = value - lowerBound;
		// console.debug("getPercentage : range ", range);
		// console.debug("getPercentage : value ", value);		
		return atRange / realRange;
	}

	toggleExpand(ev) {
		if(ev.target.className.indexOf("clear-button") < 0) {
			this.props.onSetCollapse(this.props.field, !(this.props.collapse || false));
		}
	}

	// castValueToInt(value) {
	// 	if ( value ) {
	// 		return parseInt(value);
	// 	}
	// }

	handleLowerValueChange(ev) {
		this.setState({ lowerValue: ev.target.value });
	}

	handleUpperValueChange(ev) {
		this.setState({ upperValue: ev.target.value });
	}

	render() {
		const { label, field, bootstrapCss, collapse } = this.props;
		const { value } = this.state;

		const range = this.facetsToRange();

		const filterRange = value.length > 0 ? value : range;

		return (
			<li className={cx("facet-box","range-facet", {"list-group-item col-md-5 col-sm-12": bootstrapCss})} id={`solr-range-facet-${field}`}>
				<header onClick={this.toggleExpand.bind(this)}>
					<h5>
						{bootstrapCss ? (<span>
						<span className={cx("glyphicon", {
							"glyphicon-collapse-down": !collapse,
							"glyphicon-collapse-up": collapse
						})} />{" "}
						</span>) : null }
						{label}
					</h5>
				</header>

				<div style={{display: collapse ? "none" : "block"}}>
					<RangeSlider lowerLimit={this.getPercentage(range, filterRange[0])} onChange={this.onRangeChange.bind(this)} upperLimit={this.getPercentage(range, filterRange[1])} />
					<div className={cx({"row": bootstrapCss})}>
						<label>{filterRange[0]}</label>
						<label className={cx({"pull-right": bootstrapCss})}>{filterRange[1]}</label>
					</div>
					<div className={cx({"row": bootstrapCss})}>
						<div className={cx({"col-md-4 col-sm-4 pull-left": bootstrapCss})}>
							<input id="input-range-left" className={cx("range-input", {"form-control input-sm": bootstrapCss})} 
									type="text"
									value={this.state.lowerValue}
									onChange={this.handleLowerValueChange}
									onKeyDown={this.handleKeyDown.bind(this)}/>
						</div>
						<div className={cx({"col-md-4 col-sm-4 pull-right": bootstrapCss})}>
							<input id="input-range-right" className={cx("range-input", {"form-control input-sm": bootstrapCss})}
									type="text"
									value={this.state.upperValue}
									onChange={this.handleUpperValueChange}
									onKeyDown={this.handleKeyDown.bind(this)}/>
						</div>
					</div>
					<div>
						<button className={cx("clear-button", { "btn": bootstrapCss, "btn-default": bootstrapCss, "btn-xs": bootstrapCss, "pull-right": bootstrapCss })}
								onClick={() => this.props.onChange(field, [])}>
							Reset
						</button>
					</div>
				</div>
			</li>
		);
	}
}

RangeFacet.defaultProps = {
	value: []
};

RangeFacet.propTypes = {
	bootstrapCss: PropTypes.bool,
	collapse: PropTypes.bool,
	// facets: PropTypes.array.isRequired,
	field: PropTypes.string.isRequired,
	label: PropTypes.string,
	onChange: PropTypes.func,
	onSetCollapse: PropTypes.func,
	value: PropTypes.array,
};

export default RangeFacet;
